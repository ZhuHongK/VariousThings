## 1、如何排查一条慢SQL？可以从哪些方面入手？（SQL）
1. 如果是一个sql，可以通过explain的指令去查这个sql的执行计划。（索引失效会导致sql的执行变为全表扫描或选择错误的索引，在explain中一般是type=ALL或者type=index）
2. 如果有数据库终端的话，也可以通过开启mysql的慢日志查询，设置好时间阈值，进行捕获
## SQL优化
SQL语句的优化方式主要是通过选择合适的索引、优化查询语句、避免全表扫描等提高查询效率，减少慢SQL的出现
### 索引
索引主要用于加快数据的查询速度，有了正确的索引，数据库就可以根据索引的数据结构快速定位到匹配的数据行，从而提高查询效率和响应速度。在慢SQL中由于索引导致的主要有两个方面：**索引缺失**（没有索引） 与 **索引失效**

一般在以下场景需要为相应的列创建索引：
- 字段有唯一性限制
- 经常用于where查询条件的字段
- 经常用于group by和order by的字段，可以避免排序

但并不是每个字段都要添加上索引，以下场景添加上索引会加重DB的负担：
- 不用于查询条件的字段
- 字段中存在大量重复的数据
- 数据量太少
- 频繁更新的字段（考虑）

## 2、说一说关于lambda函数的知识（C++）
1. 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象
2. 每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，lambda表达式就会返回一个匿名的闭包实例，其实一个右值
3. lambda可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体

## 3、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？（计网）
1. 域名解析 
   - 查浏览器本地缓存
   - 检查本机host文件
   - 向DNS服务器发送DNS查询请求获取IP地址
2. 发起TCP的3次握手
3. 建立TCP连接后发起http请求
4. 服务器响应http请求，浏览器得到html代码
5. 浏览器解析html代码，并请求html代码中的资源（js、css、图片等）
6. 浏览器对页面进行渲染呈现给用户

## 4、如何设计一个高性能/高并发/高可用/高可靠/可扩展的系统? 
1. 无锁化
2. 零拷贝
3. 序列化
4. 池子化
5. 并发化
6. 异步化
7. 缓存
8. 分片
9. 存储

## 5、事务四大特性（ACID）原子性、一致性、隔离性、永久性（MySql）
### 原子性
原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响
### 一致性
事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到
### 隔离性
隔离性是当多个用户并发访问数据库时，比如操作同一张表，数据库为每一个用户开启的事务，不能被其他事务所干扰，多个并发事务之间要相互隔离。
同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

事务隔离分为不同级别，包括读未提交、读提交、可重复读和串行化
### 持久性
持久性是指一个事物一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作

## 6、接雨水（数据结构）
[link](https://leetcode.cn/problems/trapping-rain-water/)
![Alt text](./picture/image-1.png)

## 7、TCP是如何保证可靠传输的？（计网）
tcp的序列号可以避免乱序的问题，保证收到的tcp报文都是有序的。
在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。
TCP 针对数据包丢失的情况，会用重传机制解决。
用快重传解决个别报文段的丢失问题。
使用滑动窗口实现流量控制。使用接收方确认报文中的窗口字段来控制发送方发送窗口大小，进而控制发送方的发送速率，使得接收方来得及接收。
使用基于窗口的拥塞控制，来尽量避免避免网络拥塞。
- 建立连接（标志位）：通信前确认通信实体存在
- 序号机制（序号、确认号）：确保了数据是按序、完整到达
- 数据校验（校验和）：CRC校验全部数据
- 超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发
- 窗口机制（窗口）：提供流量控制，避免过量发送
- 拥塞控制：同上

## 8、线程与进程的比较或者说区别？（操作系统）
关于线程：线程启动速度快，轻量级；线程的系统开销小；线程使用有一定难度，需要处理数据一致性问题；同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈
- 调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）
- 并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发
- 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位
- 系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构（是Linux中描述进程的结构体）

## 9、数据库的事务隔离级别有哪些？（MySql）
### 未提交读
事务中发生了修改，即使没有提交，其他事务也是可见的。比如对于一个数A原来50修改为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，但是另一个事务看到的A是100。**可能导致脏读、幻读或不可重复读**
### 提交读
对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的。举例就是对于一个数A原来是50，然后提交修改为100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了。**可以阻止脏读，但是幻读或不可重复读仍有可能发生**
### 重复读
就是对一个记录读取多次的记录是相同的。比如对于一个数A读取的话一直是A，前后两次读取的A是一致的。**可以阻止脏读和不可重复读，但幻读仍有可能发生**
### 可串行化读
在并发情况下，和串行化的读取的结果是一致的，没有什么不同。比如不会发生脏读和幻读。**该级别可以防止脏读、不可重复读以及幻读**

![Alt text](./picture/image-2.png)

MySql InnoDB 存储引擎的默认支持的隔离级别是REPEATABLE-READ（可重读）

## 10、C++11有哪些新特性？（C++）
- nullptr代替了NULL
- 引入了 auto 和 decltype 这两个关键字实现了类型推导
- 基于范围的for循环 for (auto &i : res) {}
- 类和结构体的初始化列表
- Lambda表达式（匿名函数）
- std::forward_list（单向链表）
- 右值引用和move语义
- 无序容器和正则表达式
- 成员变量默认初始化
- 智能指针等

## 11、Linux和Windows下的进程通信方法和线程通信方法分别有哪些？（操作系统）
### 进程通信方法
![Alt text](./picture/image-3.png)
- **管道**（pipe）：允许一个进程和另一个与它有共同祖先的进程之间进行通信
- **命名管道**（FIFO）：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命名mkfifo或系统调用mkfifo来创建
- **消息队列**（MQ）：消息队列是消息的连接表，包括POSIX消息队列和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点
- **信号量**（semaphore）：信号量主要作为进程间以及同进程不同线程之间的同步手段
- **共享内**存(shared memory)：它使得多个进程可以访问同一块内存空间， **是最快的可用IPC形式。** 这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥
- **信号**（signal）：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身
- **内存映射**(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它
- **Socket**：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信
### 线程通信方法
#### Linux
- **信号**：类似进程间的信号处理
- **锁机制**：互斥锁、读写锁和自旋锁
- **条件变量**：使用通知的方式解锁，与互斥锁配合使用
- **信号量**：包括无名线程信号量和命名线程信号量
#### Windows
- **全局变量**：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化
- **Message消息机制**：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口
- **CEvent对象**：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法

## 12、TCP和UDP的区别（计网）
1. TCP是面向连接的协议，建立和释放连接需要进行三次握手和四次挥手。UDP是面向无连接的协议，无需进行三次握手和四次挥手。说明udp比TCP实时性更强。
2. TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。
3. TCP连接的可靠性强，UDP的可靠性不强
4. TCP只能一对一，UDP支持一对多和多对多
5. TCP的头部开销比UDP大。TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

## 13、具体说一下计算机网路三握四挥中的四挥？尽可能说的具体点（计网）
建立一个连接需要三次握手，而终止一个连接要经过四次挥手。这由TCP的半关闭（half-close）造成的。

所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。
### 初始化状态
客户端和服务端都在连接状态，接下来开始进行四次分手断开连接操作
### 第一次挥手
第一次分手无论是客户端还是服务端都可以发起，因为 TCP 是全双工的。

假如客户端发送的数据已经发送完毕，发送FIN = 1（seq = u）告诉服务端。此时客户端处于 FIN_WAIT1 状态，不再发送数据，等待服务端确认。
### 第二次挥手
服务端接收到客户端的释放请求连接之后，会发送ACK = 1（确认号ack = u + 1）告诉客户端收到你发给我的信息，此时服务端处于 CLOSE_WAIT 等待关闭状态。客户端收到确认后进入FIN_WAIT2状态
### 第三次挥手
如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号（w）。服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
### 第四次挥手
客户端收到 FIN 之后，发送一个 ACK = 1，确认号 = w + 1 的报文作为应答，此时客户端处于 TIME_WAIT 状态。服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。